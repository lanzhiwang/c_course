/**
<< 左移
>> 右移

左移和右移是移动"二进制补码"

原码: 是最简单的机器数表示法, 用最高位表示符号位, 其他位存放该数的二进制的绝对值.
反码: 正数的反码和原码一致; 负数的反码就是它的原码除符号位外, 按位取反.
补码: 正数的原码、反码、补码都一致; 负数的补码等于反码 +1.

数值   二进制原码   二进制反码   二进制补码
1     0001        0001       0001
2     0010        0010       0010
3     0011        0011       0011
4     0100        0100       0100
5     0101        0101       0101
6     0110        0110       0110
-1    1001        1110       1111
-2    1010        1101       1110
-3    1011        1100       1101
-4    1100        1011       1100
-5    1101        1010       1011
-6    1110        1001       1010

 */

#include <stdio.h>
#include <stdlib.h>

/**
返回整数 n 的二进制原码表示
 */
char *int_to_binary(int n)
{
	// 为了存储二进制表示, 分配空间 (包括符号位和字符串结束符)
	char *binary = (char *)malloc(sizeof(char) * (sizeof(int) * 8 + 1));
	unsigned int mask = 1 << (sizeof(int) * 8 - 1);	// 获取最高位的掩码
	int index = 0;

	// 处理正数或零
	if (n >= 0) {
		for (int i = 0; i < sizeof(int) * 8; i++) {
			binary[index++] = (n & mask) ? '1' : '0';
			mask >>= 1;
		}
	} else {
		// 负数, 符号位为1, 剩余部分为绝对值的二进制表示
		binary[index++] = '1';	// 符号位为1
		unsigned int abs_n = (unsigned int)(-n);	// 负数的绝对值
		mask = 1 << (sizeof(int) * 8 - 2);	// 去除符号位
		for (int i = sizeof(int) * 8 - 2; i >= 0; i--) {
			binary[index++] = (abs_n & mask) ? '1' : '0';
			mask >>= 1;
		}
	}
	binary[index] = '\0';	// 添加字符串结束符
	return binary;
}

/**
返回整数 n 的反码表示
 */
char *int_to_one_complement(int n)
{
	// 获取原码二进制表示
	char *binary = int_to_binary(n);
	char *one_complement =
	    (char *)malloc(sizeof(char) * (sizeof(int) * 8 + 1));
	int len = sizeof(int) * 8;

	if (n >= 0) {
		// 对于正数, 反码和原码相同
		for (int i = 0; i < len; i++) {
			one_complement[i] = binary[i];
		}
		one_complement[len] = '\0';
	} else {
		// 对于负数, 反码是原码除符号位外的取反
		for (int i = 1; i < len; i++) {
			one_complement[i] = (binary[i] == '1') ? '0' : '1';
		}
		one_complement[0] = '1';	// 符号位不变
		one_complement[len] = '\0';
	}

	// 释放原码的内存
	free(binary);
	return one_complement;
}

/**
函数返回整数 n 的补码表示
 */
char *int_to_two_complement(int n)
{
	// 获取反码
	char *one_complement = int_to_one_complement(n);
	char *two_complement =
	    (char *)malloc(sizeof(char) * (sizeof(int) * 8 + 1));
	int len = sizeof(int) * 8;

	if (n >= 0) {
		// 对于正数, 补码和原码相同
		for (int i = 0; i < len; i++) {
			two_complement[i] = one_complement[i];
		}
		two_complement[len] = '\0';
	} else {
		// 对于负数, 补码是反码加1
		int carry = 1;	// 加1的进位
		for (int i = len - 1; i >= 0; i--) {
			if (one_complement[i] == '1') {
				two_complement[i] = (carry == 1) ? '0' : '1';
			} else {
				two_complement[i] = (carry == 1) ? '1' : '0';
				carry = 0;	// 加完1后不再有进位
			}
		}
		two_complement[len] = '\0';
	}

	// 释放反码的内存
	free(one_complement);
	return two_complement;
}

int main(void)
{
	int i = -6;
	for (i = -6; i < 7; i++) {
		// 获取原码
		char *binary = int_to_binary(i);

		// 获取反码
		char *one_complement = int_to_one_complement(i);

		// 获取补码
		char *two_complement = int_to_two_complement(i);

		printf("i = %d, 原码=%s, 反码=%s, 补码=%s\n", i, binary,
		       one_complement, two_complement);

		// 释放内存
		free(binary);
		free(one_complement);
		free(two_complement);
	}
	printf("%+d, %032b, %032b\n", 6, 6, 6 >> 2);
	printf("%+d, %032b, %032b\n", -6, -6, -6 >> 2);

	printf("%032b\n", -6 & -5);
	printf("%032b\n", -6 | -5);
	printf("%032b\n", ~(-6));
	return 0;
}

/**

# ./main
i = -6, 原码=10000000000000000000000000000110, 反码=11111111111111111111111111111001, 补码=11111111111111111111111111111010
i = -5, 原码=10000000000000000000000000000101, 反码=11111111111111111111111111111010, 补码=11111111111111111111111111111011
i = -4, 原码=10000000000000000000000000000100, 反码=11111111111111111111111111111011, 补码=11111111111111111111111111111100
i = -3, 原码=10000000000000000000000000000011, 反码=11111111111111111111111111111100, 补码=11111111111111111111111111111101
i = -2, 原码=10000000000000000000000000000010, 反码=11111111111111111111111111111101, 补码=11111111111111111111111111111110
i = -1, 原码=10000000000000000000000000000001, 反码=11111111111111111111111111111110, 补码=11111111111111111111111111111111
i = 0, 原码=00000000000000000000000000000000, 反码=00000000000000000000000000000000, 补码=00000000000000000000000000000000
i = 1, 原码=00000000000000000000000000000001, 反码=00000000000000000000000000000001, 补码=00000000000000000000000000000001
i = 2, 原码=00000000000000000000000000000010, 反码=00000000000000000000000000000010, 补码=00000000000000000000000000000010
i = 3, 原码=00000000000000000000000000000011, 反码=00000000000000000000000000000011, 补码=00000000000000000000000000000011
i = 4, 原码=00000000000000000000000000000100, 反码=00000000000000000000000000000100, 补码=00000000000000000000000000000100
i = 5, 原码=00000000000000000000000000000101, 反码=00000000000000000000000000000101, 补码=00000000000000000000000000000101
i = 6, 原码=00000000000000000000000000000110, 反码=00000000000000000000000000000110, 补码=00000000000000000000000000000110
+6, 00000000000000000000000000000110, 00000000000000000000000000000001
-6, 11111111111111111111111111111010, 11111111111111111111111111111110

11111111111111111111111111111010
11111111111111111111111111111011
00000000000000000000000000000101

root@b8dde63c5997:/code#

#

 */
